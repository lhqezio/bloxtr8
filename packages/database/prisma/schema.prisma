// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client"
  output        = "../src/generated/prisma"
  moduleFormat  = "esm"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x", "debian-openssl-3.0.x", "darwin-arm64"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL_PRISMA")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String
  emailVerified Boolean   @default(false)
  phone         String?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
  sessions      Session[]
  accounts      Account[]

  // KYC tiers
  kycTier     KycTier @default(TIER_0)
  kycVerified Boolean @default(false)

  // Wallet screening
  walletAddress String?
  walletRisk    WalletRisk @default(UNKNOWN)

  // Relations
  listings           Listing[]
  buyerOffers        Offer[]             @relation("BuyerOffers")
  sellerOffers       Offer[]             @relation("SellerOffers")
  signatures         Signature[]
  auditLogs          AuditLog[]
  deliveries         Delivery[]
  disputes           Dispute[]           @relation("DisputeUser")
  guildMemberships   GuildMember[]
  assetVerifications AssetVerification[]
  linkEvents         LinkEvent[]

  @@unique([email])
  @@index([email])
  @@index([walletAddress])
  @@map("users")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model Guild {
  id          String   @id @default(cuid())
  discordId   String   @unique
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Marketplace setup tracking
  marketplaceSetup Boolean   @default(false)
  setupCompletedAt DateTime?
  lastSyncAt       DateTime?

  // Relations
  members             GuildMember[]
  listings            Listing[]
  marketplaceChannels MarketplaceChannel[]

  @@index([discordId])
  @@index([marketplaceSetup])
  @@map("guilds")
}

model GuildMember {
  id       String    @id @default(cuid())
  role     GuildRole @default(MEMBER)
  joinedAt DateTime  @default(now())

  // Relations
  userId  String
  user    User   @relation(fields: [userId], references: [id])
  guildId String
  guild   Guild  @relation(fields: [guildId], references: [id])

  @@unique([userId, guildId])
  @@index([userId])
  @@index([guildId])
  @@map("guild_members")
}

model LinkToken {
  id        String   @id @default(cuid())
  token     String   @unique
  discordId String
  purpose   String // e.g., 'roblox_link'
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([token])
  @@index([discordId])
  @@index([expiresAt])
  @@map("link_tokens")
}

model Listing {
  id        String        @id @default(cuid())
  title     String
  summary   String
  price     BigInt // Price in cents (BigInt to support large prices)
  category  String
  status    ListingStatus @default(ACTIVE)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  // Message management
  messageId           String?           @unique
  channelId           String?
  priceRange          String?
  visibility          ListingVisibility @default(PUBLIC)
  mediaUrls           Json? // Array of image/video URLs
  autoArchiveAt       DateTime?
  threadActivityScore Int               @default(0)

  // Relations
  userId          String
  user            User             @relation(fields: [userId], references: [id])
  guildId         String?
  guild           Guild?           @relation(fields: [guildId], references: [id])
  offers          Offer[]
  robloxSnapshots RobloxSnapshot[]
  deliveries      Delivery[]

  @@index([userId])
  @@index([guildId])
  @@index([status])
  @@index([category])
  @@index([messageId])
  @@index([visibility])
  @@index([priceRange])
  @@map("listings")
}

model Offer {
  id         String      @id @default(cuid())
  amount     BigInt // Amount in cents (BigInt to support large offers)
  currency   Currency    @default(USD)
  conditions String?
  expiry     DateTime
  status     OfferStatus @default(PENDING)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  // Relations
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id])
  buyerId   String
  buyer     User    @relation("BuyerOffers", fields: [buyerId], references: [id])
  sellerId  String
  seller    User    @relation("SellerOffers", fields: [sellerId], references: [id])

  // Parent offer for counter offers
  parentId String?
  parent   Offer?  @relation("OfferCounter", fields: [parentId], references: [id])
  counters Offer[] @relation("OfferCounter")

  contracts  Contract[]
  escrows    Escrow[]
  deliveries Delivery[]

  @@index([listingId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([expiry])
  @@map("offers")
}

model Contract {
  id        String         @id @default(cuid())
  pdfUrl    String?
  sha256    String?
  status    ContractStatus @default(PENDING_SIGNATURE)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  // Relations
  offerId    String
  offer      Offer       @relation(fields: [offerId], references: [id])
  signatures Signature[]
  escrows    Escrow[]
  deliveries Delivery[]

  @@index([offerId])
  @@index([status])
  @@map("contracts")
}

model Signature {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id])
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id])
  signedAt   DateTime @default(now())

  @@unique([userId, contractId])
  @@index([userId])
  @@index([contractId])
  @@map("signatures")
}

model Escrow {
  id        String       @id @default(cuid())
  rail      EscrowRail
  amount    BigInt // Amount in cents (BigInt to support large escrows)
  currency  Currency     @default(USD)
  status    EscrowStatus @default(AWAIT_FUNDS)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // Relations
  offerId    String
  offer      Offer    @relation(fields: [offerId], references: [id])
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id])

  // Rail-specific data
  stripeEscrow     StripeEscrow?
  stablecoinEscrow StablecoinEscrow?
  milestoneEscrow  MilestoneEscrow[]

  auditLogs  AuditLog[]
  deliveries Delivery[]
  disputes   Dispute[]

  @@index([offerId])
  @@index([contractId])
  @@index([status])
  @@index([rail])
  @@map("escrows")
}

model StripeEscrow {
  id              String  @id @default(cuid())
  paymentIntentId String  @unique
  transferId      String?
  refundId        String?

  escrowId String @unique
  escrow   Escrow @relation(fields: [escrowId], references: [id])

  @@map("stripe_escrows")
}

model StablecoinEscrow {
  id          String  @id @default(cuid())
  chain       String  @default("BASE")
  depositAddr String
  depositTx   String?
  releaseTx   String?

  escrowId String @unique
  escrow   Escrow @relation(fields: [escrowId], references: [id])

  @@map("stablecoin_escrows")
}

model MilestoneEscrow {
  id          String       @id @default(cuid())
  title       String
  amountCents Int
  status      EscrowStatus @default(AWAIT_FUNDS)

  escrowId String
  escrow   Escrow @relation(fields: [escrowId], references: [id])

  @@index([escrowId])
  @@map("milestone_escrows")
}

model Delivery {
  id          String         @id @default(cuid())
  title       String
  description String?
  status      DeliveryStatus @default(PENDING)
  deliveredAt DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  listingId       String
  listing         Listing  @relation(fields: [listingId], references: [id])
  offerId         String
  offer           Offer    @relation(fields: [offerId], references: [id])
  contractId      String
  contract        Contract @relation(fields: [contractId], references: [id])
  escrowId        String
  escrow          Escrow   @relation(fields: [escrowId], references: [id])
  deliveredBy     String
  deliveredByUser User     @relation(fields: [deliveredBy], references: [id])

  @@index([listingId])
  @@index([offerId])
  @@index([contractId])
  @@index([escrowId])
  @@index([deliveredBy])
  @@index([status])
  @@map("deliveries")
}

model Dispute {
  id          String        @id @default(cuid())
  title       String
  description String
  status      DisputeStatus @default(OPEN)
  resolution  String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  resolvedAt  DateTime?

  // Relations
  escrowId String
  escrow   Escrow @relation(fields: [escrowId], references: [id])
  userId   String
  user     User   @relation("DisputeUser", fields: [userId], references: [id])

  @@index([escrowId])
  @@index([userId])
  @@index([status])
  @@map("disputes")
}

model RobloxSnapshot {
  id                String            @id @default(cuid())
  gameId            String // Roblox game ID
  gameName          String
  gameDescription   String?
  thumbnailUrl      String?
  playerCount       Int? // Current player count
  visits            Int? // Total visits
  createdDate       DateTime?
  verifiedOwnership Boolean           @default(false)
  ownershipType     GameOwnershipType @default(OWNER)
  verificationDate  DateTime?
  metadata          Json? // Additional game metadata
  createdAt         DateTime          @default(now())

  // Relations
  listingId String?
  listing   Listing? @relation(fields: [listingId], references: [id])

  @@index([gameId])
  @@index([listingId])
  @@index([verifiedOwnership])
  @@index([verificationDate])
  @@map("roblox_snapshots")
}

model AssetVerification {
  id                 String             @id @default(cuid())
  userId             String
  gameId             String
  verificationStatus VerificationStatus @default(PENDING)
  verificationMethod VerificationMethod
  ownershipType      GameOwnershipType  @default(OWNER)
  verifiedAt         DateTime?
  expiresAt          DateTime?
  metadata           Json? // API response data
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@unique([userId, gameId], name: "userId_gameId")
  @@index([userId])
  @@index([gameId])
  @@index([verificationStatus])
  @@map("asset_verifications")
}

model AuditLog {
  id        String   @id @default(cuid())
  action    String
  details   Json?
  createdAt DateTime @default(now())

  // Relations
  userId   String?
  user     User?   @relation(fields: [userId], references: [id])
  escrowId String?
  escrow   Escrow? @relation(fields: [escrowId], references: [id])

  @@index([userId])
  @@index([escrowId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model WebhookEvent {
  id        String   @id @default(cuid())
  eventId   String   @unique
  provider  String // 'stripe', 'custodian', etc.
  processed Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([eventId])
  @@index([provider])
  @@index([processed])
  @@map("webhook_events")
}

model MarketplaceChannel {
  id             String   @id @default(cuid())
  guildId        String
  guild          Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  channelId      String // Discord channel ID
  priceRange     String // e.g., "under-5k", "5k-20k", "20k-100k", "100k+"
  activeListings Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([guildId, priceRange])
  @@index([guildId])
  @@index([channelId])
  @@index([priceRange])
  @@map("marketplace_channels")
}

// Enums
enum KycTier {
  TIER_0 // Signed up - no Roblox account
  TIER_1 // Signed up - Roblox linked - can post listings
  TIER_2 // Signed up - Roblox linked - verified by Bloxtr8 team
}

enum WalletRisk {
  UNKNOWN
  LOW
  MEDIUM
  HIGH
  SANCTIONED
}

enum ListingStatus {
  ACTIVE
  INACTIVE
  SOLD
  CANCELLED
}

enum ListingVisibility {
  PUBLIC // Visible across all guilds
  PRIVATE // Visible only in the guild where created
}

enum OfferStatus {
  PENDING
  ACCEPTED
  COUNTERED
  DECLINED
  EXPIRED
}

enum ContractStatus {
  PENDING_SIGNATURE
  EXECUTED
  VOID
}

enum EscrowRail {
  STRIPE
  USDC_BASE
}

enum VerificationStatus {
  PENDING
  VERIFIED
  FAILED
  EXPIRED
}

enum VerificationMethod {
  GAME_OWNERSHIP_API
  GAME_PERMISSIONS_API
  MANUAL
}

enum GameOwnershipType {
  OWNER
  ADMIN
  DEVELOPER
}

enum EscrowStatus {
  AWAIT_FUNDS
  FUNDS_HELD
  DELIVERED
  RELEASED
  DISPUTED
  REFUNDED
  CANCELLED
}

enum Currency {
  USD
  USDC
}

enum GuildRole {
  MEMBER
  MODERATOR
  ADMIN
  OWNER
}

enum DeliveryStatus {
  PENDING
  IN_PROGRESS
  DELIVERED
  CONFIRMED
  REJECTED
}

enum DisputeStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  CLOSED
}

// Link events for tracking when users link accounts (for DM notifications)
model LinkEvent {
  id          String   @id @default(cuid())
  userId      String
  providerId  String   // 'roblox', 'discord', etc.
  accountId   String   // The external account ID
  notified    Boolean  @default(false) // Whether Discord bot has sent notification
  createdAt   DateTime @default(now())
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([notified, createdAt])
  @@index([userId])
}
