// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client"
  output        = "../src/generated/prisma"
  moduleFormat  = "esm"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x", "debian-openssl-3.0.x", "darwin-arm64"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL_PRISMA")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String
  emailVerified Boolean   @default(false)
  phone         String?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
  sessions      Session[]
  accounts      Account[]

  // KYC tiers
  kycTier     KycTier @default(TIER_0)
  kycVerified Boolean @default(false)

  // Wallet screening
  walletAddress String?
  walletRisk    WalletRisk @default(UNKNOWN)
  
  // Stripe Connect
  stripeAccountId String? // Stripe Connect account ID for sellers

  // Relations
  listings           Listing[]
  buyerOffers        Offer[]             @relation("BuyerOffers")
  sellerOffers       Offer[]             @relation("SellerOffers")
  signatures         Signature[]
  auditLogs          AuditLog[]
  deliveries         Delivery[]
  disputes           Dispute[]           @relation("DisputeUser")
  guildMemberships   GuildMember[]
  assetVerifications AssetVerification[]
  linkEvents         LinkEvent[]

  @@unique([email])
  @@index([email])
  @@index([walletAddress])
  @@map("users")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model Guild {
  id          String   @id @default(cuid())
  discordId   String   @unique
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Marketplace setup tracking
  marketplaceSetup Boolean   @default(false)
  setupCompletedAt DateTime?
  lastSyncAt       DateTime?

  // Relations
  members             GuildMember[]
  listings            Listing[]
  marketplaceChannels MarketplaceChannel[]

  @@index([discordId])
  @@index([marketplaceSetup])
  @@map("guilds")
}

model GuildMember {
  id       String    @id @default(cuid())
  role     GuildRole @default(MEMBER)
  joinedAt DateTime  @default(now())

  // Relations
  userId  String
  user    User   @relation(fields: [userId], references: [id])
  guildId String
  guild   Guild  @relation(fields: [guildId], references: [id])

  @@unique([userId, guildId])
  @@index([userId])
  @@index([guildId])
  @@map("guild_members")
}

model LinkToken {
  id        String   @id @default(cuid())
  token     String   @unique
  discordId String
  purpose   String // e.g., 'roblox_link'
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([token])
  @@index([discordId])
  @@index([expiresAt])
  @@map("link_tokens")
}

model Listing {
  id        String        @id @default(cuid())
  title     String
  summary   String
  price     BigInt // Price in cents (BigInt to support large prices)
  category  String
  status    ListingStatus @default(ACTIVE)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  // Message management
  messageId           String?           @unique
  channelId           String?
  priceRange          String?
  visibility          ListingVisibility @default(PUBLIC)
  mediaUrls           Json? // Array of image/video URLs
  autoArchiveAt       DateTime?
  threadActivityScore Int               @default(0)

  // Relations
  userId          String
  user            User             @relation(fields: [userId], references: [id])
  guildId         String?
  guild           Guild?           @relation(fields: [guildId], references: [id])
  offers          Offer[]
  robloxSnapshots RobloxSnapshot[]
  deliveries      Delivery[]

  @@index([userId])
  @@index([guildId])
  @@index([status])
  @@index([category])
  @@index([messageId])
  @@index([visibility])
  @@index([priceRange])
  @@map("listings")
}

model Offer {
  id         String      @id @default(cuid())
  amount     BigInt // Amount in cents (BigInt to support large offers)
  currency   Currency    @default(USD)
  conditions String?
  expiry     DateTime
  status     OfferStatus @default(PENDING)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  // Relations
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id])
  buyerId   String
  buyer     User    @relation("BuyerOffers", fields: [buyerId], references: [id])
  sellerId  String
  seller    User    @relation("SellerOffers", fields: [sellerId], references: [id])

  // Parent offer for counter offers
  parentId String?
  parent   Offer?  @relation("OfferCounter", fields: [parentId], references: [id])
  counters Offer[] @relation("OfferCounter")

  contracts  Contract[]
  escrows    Escrow[]
  deliveries Delivery[]

  @@index([listingId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([expiry])
  @@map("offers")
}

model OfferDraft {
  id            String   @id @default(cuid())
  discordUserId String // Discord user ID (not internal user ID yet)
  listingId     String
  amount        BigInt // Amount in cents
  conditions    String?
  expiresAt     DateTime // Auto-cleanup after this time
  createdAt     DateTime @default(now())

  @@unique([discordUserId, listingId]) // One draft per user per listing
  @@index([expiresAt]) // For cleanup queries
  @@index([discordUserId])
  @@map("offer_drafts")
}

model Contract {
  id              String         @id @default(cuid())
  pdfUrl          String?
  sha256          String?
  status          ContractStatus @default(PENDING_SIGNATURE)
  robloxAssetData Json? // Snapshot of Roblox asset details at time of contract
  templateVersion String         @default("1.0.0") // Contract template version used
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  offerId       String
  offer         Offer                  @relation(fields: [offerId], references: [id])
  signatures    Signature[]
  escrows       Escrow[]
  deliveries    Delivery[]
  executionJobs ContractExecutionJob[]

  @@index([offerId])
  @@index([status])
  @@map("contracts")
}

model ContractExecutionJob {
  id                  String    @id @default(cuid())
  contractId          String
  contract            Contract  @relation(fields: [contractId], references: [id])
  status              JobStatus @default(PENDING)
  attempts            Int       @default(0)
  maxAttempts         Int       @default(3)
  lastError           String?
  nextRetryAt         DateTime?
  processingStartedAt DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  completedAt         DateTime?

  @@unique([contractId]) // Prevent duplicate execution jobs per contract
  @@index([contractId])
  @@index([status, nextRetryAt])
  @@map("contract_execution_jobs")
}

model Signature {
  id              String          @id @default(cuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id])
  contractId      String
  contract        Contract        @relation(fields: [contractId], references: [id])
  signedAt        DateTime        @default(now())
  ipAddress       String? // IP address at time of signing
  userAgent       String? // Browser/client user agent
  signatureMethod SignatureMethod @default(DISCORD_NATIVE) // How the signature was captured

  @@unique([userId, contractId])
  @@index([userId])
  @@index([contractId])
  @@map("signatures")
}

model Escrow {
  id        String       @id @default(cuid())
  rail      EscrowRail
  amount    BigInt // Amount in cents (BigInt to support large escrows)
  currency  Currency     @default(USD)
  status    EscrowStatus @default(AWAIT_FUNDS)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // New fields from escrow spec
  expiresAt     DateTime? // Auto refund deadline
  autoRefundAt  DateTime? // For automatic release after delivery
  metadata      Json?     // Rails-agnostic references (refund reasons, proofs, custodian IDs)
  version       Int       @default(1) // Optimistic locking

  // Relations
  offerId    String
  offer      Offer    @relation(fields: [offerId], references: [id])
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id])

  // Rail-specific data
  stripeEscrow     StripeEscrow?
  stablecoinEscrow StablecoinEscrow?
  milestoneEscrow  MilestoneEscrow[]

  auditLogs  AuditLog[]
  deliveries Delivery[]
  disputes   Dispute[]
  events     EscrowEvent[]
  paymentArtifacts PaymentArtifact[]

  @@index([offerId])
  @@index([contractId])
  @@index([status])
  @@index([rail])
  @@map("escrows")
}

model StripeEscrow {
  id              String  @id @default(cuid())
  paymentIntentId String  @unique
  transferId      String?
  refundId        String?
  
  // New fields from escrow spec
  amountCaptured  Int?     // Final captured amount in cents
  currency        Currency? // Final captured currency
  lastWebhookAt   DateTime? // For idempotency & replay protection

  escrowId String @unique
  escrow   Escrow @relation(fields: [escrowId], references: [id])

  @@map("stripe_escrows")
}

model StablecoinEscrow {
  id          String  @id @default(cuid())
  chain       String  @default("BASE")
  depositAddr String
  depositTx   String?
  releaseTx   String?
  
  // New fields from escrow spec
  custodyProvider        String? // e.g., 'coinbase_prime'
  depositConfirmations   Int?    // Number of confirmations
  custodianBuyerWalletId String? // Coinbase wallet id for buyer
  custodianSellerWalletId String? // Coinbase wallet id for seller
  custodianDepositTxId   String? // Provider deposit id
  onchainSignature       String? // Onchain tx signature for release/refund
  providerEvent          Json?   // Raw webhook payload
  version                Int     @default(1) // Optimistic locking
  mintAddress            String  // Canonical USDC mint
  lastWebhookAt          DateTime? // For idempotency & replay protection


  escrowId String @unique
  escrow   Escrow @relation(fields: [escrowId], references: [id])

  @@map("stablecoin_escrows")
}

model MilestoneEscrow {
  id          String       @id @default(cuid())
  title       String
  amountCents Int
  status      EscrowStatus @default(AWAIT_FUNDS)

  escrowId String
  escrow   Escrow @relation(fields: [escrowId], references: [id])

  @@index([escrowId])
  @@map("milestone_escrows")
}

model Delivery {
  id          String         @id @default(cuid())
  title       String
  description String?
  status      DeliveryStatus @default(PENDING)
  deliveredAt DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  
  // New field from escrow spec
  evidence    Json? // Links to screenshots, roblox API responses, tx hashes, or signed messages

  // Relations
  listingId       String
  listing         Listing  @relation(fields: [listingId], references: [id])
  offerId         String
  offer           Offer    @relation(fields: [offerId], references: [id])
  contractId      String
  contract        Contract @relation(fields: [contractId], references: [id])
  escrowId        String
  escrow          Escrow   @relation(fields: [escrowId], references: [id])
  deliveredBy     String
  deliveredByUser User     @relation(fields: [deliveredBy], references: [id])

  @@index([listingId])
  @@index([offerId])
  @@index([contractId])
  @@index([escrowId])
  @@index([deliveredBy])
  @@index([status])
  @@map("deliveries")
}

model Dispute {
  id          String        @id @default(cuid())
  title       String
  description String
  status      DisputeStatus @default(OPEN)
  resolution  String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  resolvedAt  DateTime?

  // Relations
  escrowId String
  escrow   Escrow @relation(fields: [escrowId], references: [id])
  userId   String
  user     User   @relation("DisputeUser", fields: [userId], references: [id])

  @@index([escrowId])
  @@index([userId])
  @@index([status])
  @@map("disputes")
}

model RobloxSnapshot {
  id                String            @id @default(cuid())
  gameId            String // Roblox game ID
  gameName          String
  gameDescription   String?
  thumbnailUrl      String?
  playerCount       Int? // Current player count
  visits            Int? // Total visits
  createdDate       DateTime?
  verifiedOwnership Boolean           @default(false)
  ownershipType     GameOwnershipType @default(OWNER)
  verificationDate  DateTime?
  metadata          Json? // Additional game metadata
  createdAt         DateTime          @default(now())

  // Relations
  listingId String?
  listing   Listing? @relation(fields: [listingId], references: [id])

  @@index([gameId])
  @@index([listingId])
  @@index([verifiedOwnership])
  @@index([verificationDate])
  @@map("roblox_snapshots")
}

model AssetVerification {
  id                 String             @id @default(cuid())
  userId             String
  gameId             String
  verificationStatus VerificationStatus @default(PENDING)
  verificationMethod VerificationMethod
  ownershipType      GameOwnershipType  @default(OWNER)
  verifiedAt         DateTime?
  expiresAt          DateTime?
  metadata           Json? // API response data
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@unique([userId, gameId], name: "userId_gameId")
  @@index([userId])
  @@index([gameId])
  @@index([verificationStatus])
  @@map("asset_verifications")
}

model AuditLog {
  id        String   @id @default(cuid())
  action    String
  details   Json?
  createdAt DateTime @default(now())

  // New fields from escrow spec
  referenceType String? // Generic linking to events
  referenceId   String? // Generic reference ID

  // Relations
  userId   String?
  user     User?   @relation(fields: [userId], references: [id])
  escrowId String?
  escrow   Escrow? @relation(fields: [escrowId], references: [id])

  @@index([userId])
  @@index([escrowId])
  @@index([action])
  @@index([createdAt])
  @@index([referenceType])
  @@index([referenceId])
  @@map("audit_logs")
}

model WebhookEvent {
  id        String   @id @default(cuid())
  eventId   String   @unique
  provider  String // 'stripe', 'custodian', etc.
  processed Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([eventId])
  @@index([provider])
  @@index([processed])
  @@map("webhook_events")
}

model EscrowEvent {
  id        String   @id @default(cuid())
  escrowId  String
  escrow    Escrow   @relation(fields: [escrowId], references: [id], onDelete: Cascade)

  eventType String   // e.g., 'ESCROW_CREATED', 'FUNDS_HELD', 'DELIVERED', etc.
  payload   Json     // Event payload (flexible JSON structure)

  createdAt DateTime @default(now())
  version   Int      // Event version (matches Escrow.version at time of event)

  @@index([escrowId])
  @@index([eventType])
  @@index([createdAt])
  @@index([escrowId, createdAt]) // Composite for event replay
  @@map("escrow_events")
}

model Outbox {
  id          String    @id @default(cuid())
  aggregateId String    // escrowId for escrow events
  eventType   String    // Kafka event type
  payload     Bytes     // Protobuf-serialized event payload
  createdAt   DateTime  @default(now())
  publishedAt DateTime? // NULL until published to Kafka
  version     Int       @default(1) // Schema version for event

  @@index([publishedAt]) // Partial index for unpublished events
  @@index([aggregateId, createdAt]) // For debugging
  @@map("outbox")
}

model PaymentArtifact {
  id               String   @id @default(cuid())
  escrowId         String
  escrow           Escrow   @relation(fields: [escrowId], references: [id], onDelete: Cascade)

  provider         String   // 'stripe', 'custodian'
  providerPaymentId String // PaymentIntent ID, Transfer ID, Transaction Hash, etc.
  kind             PaymentArtifactKind

  amount           BigInt   // Amount in cents (or smallest unit)
  currency         Currency

  metadata         Json?    // Provider-specific data (clientSecret, transactionHash, etc.)

  createdAt        DateTime @default(now())

  @@index([escrowId])
  @@index([provider])
  @@index([providerPaymentId])
  @@index([kind])
  @@index([escrowId, kind])
  @@map("payment_artifacts")
}

model EscrowSummary {
  id        String       @id // escrowId
  rail      EscrowRail
  amount    BigInt
  currency  Currency
  status    EscrowStatus

  // Denormalized from Offer
  buyerId   String
  buyerName String?
  sellerId  String
  sellerName String?
  listingId String?
  listingTitle String?

  // Denormalized from Contract
  contractId String

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  fundsHeldAt DateTime?
  deliveredAt DateTime?
  releasedAt DateTime?
  refundedAt DateTime?
  cancelledAt DateTime?
  disputedAt DateTime?

  // Aggregated data
  deliveryCount Int @default(0)
  disputeCount Int @default(0)

  // Last event version processed
  lastEventVersion Int @default(0)
  lastProcessedAt DateTime @default(now())

  @@index([buyerId, status])
  @@index([sellerId, status])
  @@index([status, createdAt])
  @@index([listingId])
  @@index([contractId])
  @@index([lastEventVersion])
  @@map("escrow_summaries")
}

model UserEscrowHistory {
  id        String   @id @default(cuid())
  userId    String
  escrowId  String
  role      UserEscrowRole // 'BUYER' | 'SELLER'

  // Denormalized escrow data
  amount    BigInt
  currency  Currency
  status    EscrowStatus
  rail      EscrowRail

  // Denormalized counterparty info
  counterpartyId String
  counterpartyName String?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, escrowId])
  @@index([userId, status])
  @@index([userId, createdAt])
  @@index([userId, role])
  @@index([escrowId])
  @@map("user_escrow_history")
}

model PaymentHistory {
  id        String   @id @default(cuid())
  escrowId  String
  userId    String   // Buyer or seller depending on transaction type

  // Payment details
  provider  PaymentProvider // 'STRIPE' | 'CUSTODIAN'
  transactionType PaymentTransactionType // 'PAYMENT' | 'TRANSFER' | 'REFUND'
  amount    BigInt
  currency  Currency

  // Provider-specific IDs
  providerTransactionId String

  // Status
  status    PaymentStatus // 'PENDING' | 'COMPLETED' | 'FAILED'

  // Additional metadata
  transactionHash String? // For USDC transactions
  feeAmount BigInt? // Platform fee if applicable

  // Timestamps
  createdAt DateTime @default(now())
  completedAt DateTime?
  failedAt DateTime?

  @@index([escrowId])
  @@index([userId, transactionType])
  @@index([userId, createdAt])
  @@index([status, createdAt])
  @@index([provider, status])
  @@index([escrowId, transactionType])
  @@map("payment_history")
}

model EscrowStats {
  id        String   @id @default(cuid())
  userId    String
  period    StatsPeriod // 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'ALL_TIME'
  periodStart DateTime

  // Statistics
  totalEscrows Int @default(0)
  totalVolume  BigInt @default(0)
  activeEscrows Int @default(0)
  completedEscrows Int @default(0)
  disputedEscrows Int @default(0)
  refundedEscrows Int @default(0)

  // Buyer stats
  buyerEscrows Int @default(0)
  buyerVolume  BigInt @default(0)

  // Seller stats
  sellerEscrows Int @default(0)
  sellerVolume  BigInt @default(0)

  // Average values
  avgEscrowAmount BigInt @default(0)

  updatedAt DateTime @updatedAt

  @@unique([userId, period, periodStart])
  @@index([userId, period])
  @@index([periodStart])
  @@index([userId, period, periodStart])
  @@map("escrow_stats")
}

model EventProcessingState {
  id        String   @id @default(cuid())
  aggregateId String // escrowId
  lastEventId String // Last processed event ID from Kafka
  lastEventVersion Int // Last processed event version
  lastProcessedAt DateTime @default(now())

  @@unique([aggregateId])
  @@index([lastProcessedAt])
  @@map("event_processing_state")
}

model MarketplaceChannel {
  id             String   @id @default(cuid())
  guildId        String
  guild          Guild    @relation(fields: [guildId], references: [id], onDelete: Cascade)
  channelId      String // Discord channel ID
  priceRange     String // e.g., "under-5k", "5k-20k", "20k-100k", "100k+"
  activeListings Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([guildId, priceRange])
  @@index([guildId])
  @@index([channelId])
  @@index([priceRange])
  @@map("marketplace_channels")
}

// Enums
enum KycTier {
  TIER_0 // Signed up - no Roblox account
  TIER_1 // Signed up - Roblox linked - can post listings
  TIER_2 // Signed up - Roblox linked - verified by Bloxtr8 team
}

enum WalletRisk {
  UNKNOWN
  LOW
  MEDIUM
  HIGH
  SANCTIONED
}

enum ListingStatus {
  ACTIVE
  INACTIVE
  SOLD
  CANCELLED
}

enum ListingVisibility {
  PUBLIC // Visible across all guilds
  PRIVATE // Visible only in the guild where created
}

enum OfferStatus {
  PENDING
  ACCEPTED
  COUNTERED
  DECLINED
  EXPIRED
}

enum ContractStatus {
  PENDING_SIGNATURE
  EXECUTING
  EXECUTED
  EXECUTION_FAILED
  VOID
}

enum EscrowRail {
  STRIPE
  USDC_BASE
}

enum VerificationStatus {
  PENDING
  VERIFIED
  FAILED
  EXPIRED
}

enum VerificationMethod {
  GAME_OWNERSHIP_API
  GAME_PERMISSIONS_API
  MANUAL
}

enum GameOwnershipType {
  OWNER
  ADMIN
  DEVELOPER
}

enum EscrowStatus {
  AWAIT_FUNDS
  FUNDS_HELD
  DELIVERED
  RELEASED
  DISPUTED
  REFUNDED
  CANCELLED
}

enum Currency {
  USD
  USDC
}

enum GuildRole {
  MEMBER
  MODERATOR
  ADMIN
  OWNER
}

enum DeliveryStatus {
  PENDING
  IN_PROGRESS
  DELIVERED
  CONFIRMED
  REJECTED
}

enum DisputeStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  CLOSED
}

enum SignatureMethod {
  DISCORD_NATIVE // Quick sign via Discord button
  WEB_BASED // Full review and sign via web app
  API // Programmatic signature (future)
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum PaymentArtifactKind {
  INTENT            // PaymentIntent (Stripe) or Deposit Address (Custodian)
  CHARGE            // Successful charge/payment
  TRANSFER          // Transfer to seller
  REFUND            // Refund to buyer
  DEPOSIT_ADDRESS   // Deposit address (Custodian)
  SCREENING_RESULT  // Wallet screening result
}

enum UserEscrowRole {
  BUYER
  SELLER
}

enum PaymentProvider {
  STRIPE
  CUSTODIAN
}

enum PaymentTransactionType {
  PAYMENT
  TRANSFER
  REFUND
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

enum StatsPeriod {
  DAILY
  WEEKLY
  MONTHLY
  ALL_TIME
}

// Link events for tracking when users link accounts (for DM notifications)
model LinkEvent {
  id         String   @id @default(cuid())
  userId     String
  providerId String // 'roblox', 'discord', etc.
  accountId  String // The external account ID
  notified   Boolean  @default(false) // Whether Discord bot has sent notification
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([notified, createdAt])
  @@index([userId])
}

// Contract templates for versioned legal terms
model ContractTemplate {
  id           String    @id @default(cuid())
  version      String    @unique // e.g., "1.0.0", "1.1.0"
  name         String // e.g., "Roblox Asset Sale Agreement"
  terms        Json // Contract terms and clauses
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  deprecatedAt DateTime? // When this version was deprecated

  @@index([version])
  @@index([isActive])
  @@map("contract_templates")
}

// One-time tokens for contract signing authentication
model ContractSignToken {
  id         String    @id @default(cuid())
  token      String    @unique
  contractId String
  userId     String
  expiresAt  DateTime
  usedAt     DateTime? // Timestamp when the token was used
  createdAt  DateTime  @default(now())

  @@index([token])
  @@index([contractId])
  @@index([userId])
  @@index([expiresAt])
  @@map("contract_sign_tokens")
}
